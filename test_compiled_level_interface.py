#!/usr/bin/env python3
"""
Test the compiled level interface with a hardcoded CompiledLevel structure.

This script tests the C API interface by creating a hardcoded CompiledLevel
that represents the current 16x16 hardcoded room and passing it through
the C API to verify the interface works correctly.
"""

import ctypes
import sys
from typing import List, Tuple

# Constants matching C++ TileType enum
TILE_EMPTY = 0
TILE_WALL = 1
TILE_CUBE = 2
TILE_SPAWN = 3

# Load the C API library
try:
    lib = ctypes.CDLL("./build/libmadrona_escape_room_c_api.so")
except OSError:
    print("Error: Could not load libmadrona_escape_room_c_api.so")
    print("Make sure you've built the project with: make -C build -j8")
    sys.exit(1)


# Define C structures matching the C API
class MER_CompiledLevel(ctypes.Structure):
    _fields_ = [
        ("num_tiles", ctypes.c_int32),
        ("max_entities", ctypes.c_int32),
        ("width", ctypes.c_int32),
        ("height", ctypes.c_int32),
        ("scale", ctypes.c_float),
        ("tile_types", ctypes.c_int32 * 256),
        ("tile_x", ctypes.c_float * 256),
        ("tile_y", ctypes.c_float * 256),
    ]


class MER_ManagerConfig(ctypes.Structure):
    _fields_ = [
        ("exec_mode", ctypes.c_int),  # 0 = CPU, 1 = CUDA
        ("gpu_id", ctypes.c_int),
        ("num_worlds", ctypes.c_uint32),
        ("rand_seed", ctypes.c_uint32),
        ("auto_reset", ctypes.c_bool),
        ("enable_batch_renderer", ctypes.c_bool),
        ("batch_render_view_width", ctypes.c_uint32),
        ("batch_render_view_height", ctypes.c_uint32),
    ]


# Define function signatures (updated for array-based API)
lib.mer_create_manager.argtypes = [
    ctypes.POINTER(ctypes.c_void_p),  # MER_ManagerHandle* out_handle
    ctypes.POINTER(MER_ManagerConfig),  # const MER_ManagerConfig* config
    ctypes.POINTER(MER_CompiledLevel),  # const MER_CompiledLevel* compiled_levels (array)
    ctypes.c_uint32,  # uint32_t num_compiled_levels
]
lib.mer_create_manager.restype = ctypes.c_int  # MER_Result

lib.mer_validate_compiled_level.argtypes = [ctypes.POINTER(MER_CompiledLevel)]
lib.mer_validate_compiled_level.restype = ctypes.c_int

lib.mer_destroy_manager.argtypes = [ctypes.c_void_p]
lib.mer_destroy_manager.restype = ctypes.c_int

lib.mer_result_to_string.argtypes = [ctypes.c_int]
lib.mer_result_to_string.restype = ctypes.c_char_p

# Result codes
MER_SUCCESS = 0
MER_ERROR_NULL_POINTER = -1
MER_ERROR_INVALID_PARAMETER = -2


def create_hardcoded_16x16_room() -> MER_CompiledLevel:
    """
    Create a hardcoded CompiledLevel that matches the current 16x16 room.

    This represents the same room that's generated by generateHardcodedRoom()
    in level_gen.cpp - a 16x16 room with walls around the perimeter.
    """
    ROOM_SIZE = 16
    TILE_SIZE = 2.0  # World units per tile

    level = MER_CompiledLevel()
    level.width = ROOM_SIZE
    level.height = ROOM_SIZE
    level.scale = TILE_SIZE

    tiles = []
    entity_count = 0

    # Generate walls around perimeter (matching generateHardcodedRoom logic)
    for x in range(ROOM_SIZE):
        for y in range(ROOM_SIZE):
            # Only create walls on edges
            if x == 0 or x == ROOM_SIZE - 1 or y == 0 or y == ROOM_SIZE - 1:
                # Convert grid coordinates to world coordinates (center at origin)
                world_x = (x - ROOM_SIZE / 2.0) * TILE_SIZE
                world_y = (y - ROOM_SIZE / 2.0) * TILE_SIZE

                tiles.append((world_x, world_y, TILE_WALL))
                entity_count += 1

    # Add spawn point in center (agents will be placed here)
    center_x = 0.0  # World center
    center_y = 0.0  # World center
    tiles.append((center_x, center_y, TILE_SPAWN))

    # Calculate max_entities (physics entities + buffer)
    level.max_entities = entity_count + 50  # Buffer for agents, floor, etc.
    level.num_tiles = len(tiles)

    # Fill arrays
    for i in range(256):
        if i < len(tiles):
            level.tile_x[i] = tiles[i][0]
            level.tile_y[i] = tiles[i][1]
            level.tile_types[i] = tiles[i][2]
        else:
            level.tile_x[i] = 0.0
            level.tile_y[i] = 0.0
            level.tile_types[i] = TILE_EMPTY

    return level


def test_compiled_level_interface():
    """Test the compiled level interface by creating a manager with hardcoded level data."""
    print("Testing compiled level interface...")

    # Create hardcoded level
    print("Creating hardcoded 16x16 room...")
    compiled_level = create_hardcoded_16x16_room()

    print("Level created:")
    print(f"  - Size: {compiled_level.width}x{compiled_level.height}")
    print(f"  - Scale: {compiled_level.scale}")
    print(f"  - Tiles: {compiled_level.num_tiles}")
    print(f"  - Max entities: {compiled_level.max_entities}")

    # Validate the level
    print("Validating compiled level...")
    result = lib.mer_validate_compiled_level(ctypes.byref(compiled_level))
    if result != MER_SUCCESS:
        error_msg = lib.mer_result_to_string(result).decode("utf-8")
        print(f"ERROR: Level validation failed: {error_msg}")
        return False
    print("âœ“ Level validation passed")

    # Create manager config
    config = MER_ManagerConfig()
    config.exec_mode = 0  # CPU mode
    config.gpu_id = 0
    config.num_worlds = 1
    config.rand_seed = 42
    config.auto_reset = True
    config.enable_batch_renderer = False
    config.batch_render_view_width = 64
    config.batch_render_view_height = 64

    # Create manager with compiled level (using new array API)
    print("Creating manager with compiled level...")
    levels_array = (MER_CompiledLevel * 1)(compiled_level)  # Single-element array
    handle = ctypes.c_void_p()
    result = lib.mer_create_manager(
        ctypes.byref(handle),
        ctypes.byref(config),
        levels_array,
        1,  # One compiled level
    )

    if result != MER_SUCCESS:
        error_msg = lib.mer_result_to_string(result).decode("utf-8")
        print(f"ERROR: Manager creation failed: {error_msg}")
        return False

    print("âœ“ Manager created successfully with compiled level!")
    print(f"  Manager handle: {handle.value}")

    # Clean up
    print("Cleaning up...")
    result = lib.mer_destroy_manager(handle)
    if result != MER_SUCCESS:
        error_msg = lib.mer_result_to_string(result).decode("utf-8")
        print(f"WARNING: Manager cleanup failed: {error_msg}")
    else:
        print("âœ“ Manager destroyed successfully")

    return True


def test_fallback_behavior():
    """Test that nullptr compiled level falls back to Phase 2 behavior."""
    print("\nTesting fallback behavior (no compiled level)...")

    # Create manager config
    config = MER_ManagerConfig()
    config.exec_mode = 0  # CPU mode
    config.gpu_id = 0
    config.num_worlds = 1
    config.rand_seed = 42
    config.auto_reset = True
    config.enable_batch_renderer = False
    config.batch_render_view_width = 64
    config.batch_render_view_height = 64

    # Create a basic compiled level for testing
    basic_level = MER_CompiledLevel()
    basic_level.num_tiles = 0  # Use hardcoded room generation
    basic_level.width = 16
    basic_level.height = 16
    basic_level.scale = 1.0
    basic_level.max_entities = 300

    # Create manager with basic compiled level
    print("Creating manager with basic compiled level...")
    handle = ctypes.c_void_p()
    result = lib.mer_create_manager(
        ctypes.byref(handle),
        ctypes.byref(config),
        ctypes.byref(basic_level),  # Provide basic compiled level
        1,  # One compiled level
    )

    if result != MER_SUCCESS:
        error_msg = lib.mer_result_to_string(result).decode("utf-8")
        print(f"ERROR: Basic manager creation failed: {error_msg}")
        return False

    print("âœ“ Basic manager created successfully!")
    print(f"  Manager handle: {handle.value}")

    # Clean up
    result = lib.mer_destroy_manager(handle)
    if result != MER_SUCCESS:
        error_msg = lib.mer_result_to_string(result).decode("utf-8")
        print(f"WARNING: Basic manager cleanup failed: {error_msg}")
    else:
        print("âœ“ Fallback manager destroyed successfully")

    return True


if __name__ == "__main__":
    print("=== Compiled Level Interface Test ===")

    # Test 1: Interface with hardcoded compiled level
    success1 = test_compiled_level_interface()

    # Test 2: Fallback behavior
    success2 = test_fallback_behavior()

    print("\n=== Results ===")
    print(f"Compiled level test: {'PASSED' if success1 else 'FAILED'}")
    print(f"Fallback test: {'PASSED' if success2 else 'FAILED'}")

    if success1 and success2:
        print("\nðŸŽ‰ All tests passed! The compiled level interface is working correctly.")
        sys.exit(0)
    else:
        print("\nâŒ Some tests failed. Check the output above for details.")
        sys.exit(1)
